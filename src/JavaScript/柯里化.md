# 柯里化
## 柯里化使用的好处?

令函数有更好的可读性、灵活性 和 复用性。

1. 参数复用，形成一些偏函数，灵活应用
2. 将操作原子化，方便单元测试

## 基础柯里化函数实现
返回闭包，通过判断 func 和 args 的参数长度，相等时执行 func ，否则返回 curried 函数
```
const myCurry = func =>
  curried = (...args) =>
    args.length >= func.length
      ? func.call(this, ...args)
      : (...rest) => curried.call(this, ...args, ...rest);
 

const add = (a, b) => a + b
const addCurry = myCurry(add)
addCurry(1)(2)
```

```
const curryingLog = Fn
const warnLogger = curryingLog('warn')

warnLogger("message")
```
## 实际应用
#### 延迟计算 - 累加器
```
const add = (...args) => args.reduce((a, b) => a + b);
function currying(func) {
    const args = [];
    return function result(...rest) {
        if (rest.length === 0) { // 如果形数为空，求结果
          return func(...args);
        } else {
          args.push(...rest); // 参数累加，利用闭包特性
        	return result;
        }
    }
}

const sum = currying(add);
sum(1,2)(3); // 未真正求值
sum(4); 		 // 未真正求值
sum(); 			 // 输出 10
```
#### 动态创建函数
```
const getPhoneType = () => {
    if (!navigator.userAgentData.mobile) return false       
    const isIPhone = /(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)
    const isAndroid = /(Android)/i.test(navigator.userAgent)
    return {'true,false': 'isIPhone', 'false,true': 'isAndroid'}[[isIPhone, isAndroid].join()] || 'unrecognized'
}
```
我们避免每次调用都访问一次 if
```
const phoneTypeCarry = () => {
    if (!navigator.userAgentData.mobile) return () => 'unrecognized'
    return () => {
      const isIPhone = /(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)
      const isAndroid = /(Android)/i.test(navigator.userAgent)
      return {'true,false': 'isIPhone', 'false,true': 'isAndroid'}[[isIPhone, isAndroid].join()] || 'unrecognized'
    }
}
const getPhoneType = phoneTypeCarry()
getPhoneType()
```
