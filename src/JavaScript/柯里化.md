# 柯里化
## 柯里化使用的好处?

令函数有更好的可读性、灵活性 和 复用性。

1. 参数复用，形成一些偏函数，灵活应用
2. 将操作原子化，方便单元测试

## 原理
1. 我们myCurry调用应该返回一个包装器 curried，令这个函数curry化
2. curry 的使用主要看参数数量
3. 如果传入的 args 长度与原始函数所定义的（func.length）相同或者更长，
4. 那么只需要将调用传递给它即可。直接现在就调用，返回函数结果
5. 否则的话，返回另一个包装器方法，递归地调用curried，将之前传入的参数与新的参数拼接后一起传入。
6. 然后，在一个新的调用中，再次，我们将获得一个新的偏函数（如果参数不足的话），或者最终的结果。

## 基础柯里化函数实现
```
const myCurry = func =>
  curried = (...args) =>
    args.length >= func.length
      ? func.call(this, ...args)
      : (...rest) => curried.call(this, ...args, ...rest);
 

const add = (a, b) => a + b
const addCurry = myCurry(add)
addCurry(1)(2)
```

```
const curryingLog = Fn
const warnLogger = curryingLog('warn')

warnLogger("message")
```
## 实际应用
#### 延迟计算 - 累加器
```
const add = (...args) => args.reduce((a, b) => a + b);
function currying(func) {
    const args = [];
    return function result(...rest) {
        if (rest.length === 0) { // 如果形数为空，求结果
          return func(...args);
        } else {
          args.push(...rest); // 参数累加，利用闭包特性
        	return result;
        }
    }
}

const sum = currying(add);
sum(1,2)(3); // 未真正求值
sum(4); 		 // 未真正求值
sum(); 			 // 输出 10
```
#### 动态创建函数
```
const getPhoneType = () => {
    if (!navigator.userAgentData.mobile) return false       
    const isIPhone = /(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)
    const isAndroid = /(Android)/i.test(navigator.userAgent)
    return {'true,false': 'isIPhone', 'false,true': 'isAndroid'}[[isIPhone, isAndroid].join()] || 'unrecognized'
}
```
我们避免每次调用都访问一次 if
```
const phoneTypeCarry = () => {
    if (!navigator.userAgentData.mobile) return () => 'unrecognized'
    return () => {
      const isIPhone = /(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)
      const isAndroid = /(Android)/i.test(navigator.userAgent)
      return {'true,false': 'isIPhone', 'false,true': 'isAndroid'}[[isIPhone, isAndroid].join()] || 'unrecognized'
    }
}
const getPhoneType = phoneTypeCarry()
getPhoneType()
```
