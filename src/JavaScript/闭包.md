# 闭包
## 什么是闭包
>MDN: 一个函数和对其周围状态的引用捆绑在一起，这样组合就是闭包。

>红宝书: 闭包是指有权访问另外一个函数作用域中的变量的函数。

## 请讲一下你对闭包的理解
### 口述部分
1. 闭包是有权访问其他函数作用变量的函数
2. 它会引用上级作用域的变量而让函数使用完【无法清栈值和内存回收】(GC内存回收)
3. 一般用途在实现【外部访问内部变量】和【实现属性私有化】上
4. 实际用途有【回调函数】、【IIFE】、【节流防抖】、【柯里化】、【函数返回匿名函数】上

### 系统理解
#### 理论
闭包该函数**有权限访问其他函数作用域内变量**的函数。

#### 函数作用域？
1. 在JS中，变量的作用域是函数的作用域，函数在被使用之后作用域会被清理，内存会被回收
2. 闭包建立了可访问上级作用域的子函数
3. 上级函数执行完毕通常会被销毁，但由于该子函数被外部引用的存在而不会被销毁

#### 闭包内存
闭包储存在堆内存里。

(JS 堆栈内存释放)

#### 闭包解决了什么
闭包可以缓存上级作用域，“函数作用域”的束缚，外部可以访问函数内部的变量。

1. 保护函数不受外部干扰，形成不销毁的栈内存
2. 把函数内的值保存下来。实现属性和方法的私有化

#### 日常闭包例子
- 函数内部返回另一个匿名函数
- setTimeout的回调、回调函数
- IIFE 函数
- 节流防抖
- 柯里化

### 使用场景
#### 使用闭包模拟私有方法
JS中没有私有变量，可以用闭包进行模拟
```
const fn = (function() {
  const pNum = 100;
  return {
    getValue: function() {
      return pNum;
    }
  }
})();
const cFn = fn
cFn.getValue()
```
#### 柯里化函数
```
const xy = (x) => {
  return y => {
    return x * y
  }
}
xy(2)(2) // 4

function myCurry(func) {  
  return function curried(...args) {
    return args.length >= func.length ?
      func.call(this, ...args) :
      (...rest) => {
        return curried.call(this, ...args, ...rest);
      };
  };
}
```

## 题目
#### 题目1
```
for (var i = 0; i < 3; i++) {
  setTimeout(function log() {
    console.log(i);
  }, 1000);
}
```
```
1. 去除变量提升，var 使用 let / const
2. 使用 IIFE 传递变量，包裹 setTimeout (why)
for (var i = 0; i < 3; i++) {
  (function(j){
    setTimeout(function log() {
        console.log(j);
      }, 1000);
  })(i)
}
```
#### 题目2
```
var result = [];
var a = 3;
var total = 0;

function foo(a) {
    for (var i = 0; i < 3; i++) {
        result[i] = function () {
            total += i * a;
            console.log(total, a, i);
        }
    }
}

foo(1);
result[0]();  // 3 1 3
result[1]();  // 6 1 3
result[2]();  // 9 1 3

# result[i] = function (){} 形成闭包, total 被外部引用所以没被销毁
```

#### 题目3
```
# 实现 partial 函数
function foo(a,b,c,d) {
  console.log(a,b,c,d)
}
function partial(fn, ...arg) {
  // 代码实现
}
const warpper = partial(foo, 1, 2)
warpper(3) // 1 2 3 undefined
warpper(3, 4) // 1 2 3 4
warpper(3, 4, 5) // 1 2 3 4

# 实现：
function partial(fn, ...arg) {
  return (...arg1) => fn(...arg, arg1)
}
```
#### 题目4
```
function createIncrement() {
  let count = 0;
  function increment() { 
    count++;
  }

  let message = `Count is ${count}`;
  function log() {
    console.log(message, count);
  }
  
  return [increment, log];
}

const [increment, log] = createIncrement();
increment(); 
log(); // ?

# 'Count is 0', 1
```
#### 题目5
```
# 重构函数
function createStack() {
  return {
    items: [],
    push(item) {
      this.items.push(item);
    },
    pop() {
      return this.items.pop();
    }
  };
}
const stack = createStack();
stack.items = [] // 栈结构被破坏
```
我们不想栈结构被外部访问那需要做一些修改
```
function createStack() {
  const items = [];
  return {
    push(item) {
      items.push(item);
    },
    pop() {
      return items.pop();
    }
  };
}
```
## 涉及知识
- 函数作用域
- 内存回收机制
- 作用域继承
