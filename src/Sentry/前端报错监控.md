# 前端报错监控
只要函数内部抛出错误，就会结束这个函数的调用并且出栈

## 报错收集方式
1. JS运行错误、资源加载错误
2. 网络请求错误
3. 未处理的 promise 错误
4. 错误边界

## 错误捕获方式
1. Try-catch
2. Promise.catch
3. window.onerror / window.addEventListener('error') / element.onerror
4. Vue.config.errorHandle
5. Vue 生命周期 errorCaptured
6. Navigator.sendBeacon()
## JS运行错误、资源加载错误
### GlobalEventHandlers.onerror
[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onerror)

#### 1. window.onerror
当 JS 发生错误的时，通过 window.onerror 收集错误信息，存 error.stack 。
```
window.onerror = function(message, source, lineno, colno, error) { ... }

window.addEventListener('error', function(event) { ... })
```

``window.onerror``: 含有详细的 error 堆栈信息，存在 error.stack 中。选择使用 window.onerror 的方式对 **js运行时错误** 进行捕获。

``window.addEventListener('error')``: 捕获加载资源( ``<img/>`` / ``<script/>`` / ``<link />``)的错误，**只能在捕获阶段，不会冒泡到 window。**

跟 window.onerror 使用需额外过滤 js 错误：
```
window.addEventListener('error', event => (){ 
  const target = event.target || event.srcElement
  const isElementTarget = target instanceof HTMLScriptElement || target instanceof HTMLLinkElement || target instanceof HTMLImageElement
  if (!isElementTarget) return false
  // 收集上报错误信息
  const errInfoUrl = target.src || target.href
  console.log(errInfoUrl)
}, true);
```

**跨域资源发生错误需要进行监听时**：
 - 浏览器会因跨域限制只返回一个 ``Script error``(表示毫无价值/无法分析的错误)
 - 我们需要在跨域的文件上添加 ``CORS`` + 引用该文件的 ``<script>.crossorigin`` 来解决。
#### 2. element.onerror
当资源加载失败时，加载资源的元素会触发一个 Event 接口的 error 事件。

**element.onerror 可单独处理错误后续的处理函数, 一般统一由外层监听进行上报。**
```
<img src="imgSrc" onerror="Fn" />

funciton Fn(event) {
 // 重置默认图
 const element = event.srcElement;
 element.src = 'new src'
 element.onerror = null // 关闭 onerror 避免重复报错
}
```

## 网络请求错误
``window.addEventListener('error')``可以对我们的资源(网络请求)进行收集， ``event.currentTarget.status !== 200``，所以当我们使用监听捕获错误而又想独立使用``xhr``/``axios``的内部错误处理逻辑时，需要在定义 ``window.addEventListener('error')`` 和 网络请求错误处理进行取舍。

以网络请求为例子，当接口能正常访问到服务器时，接口的``HTTP Status Code``统一为200，而对接口信息的处理则嵌入``response``内。而``window.addEventListener('error')``针对无法正常访问到服务器而收集错误信息。

## 未处理的 promise 错误
[window.unhandleRejection](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/unhandledrejection_event): 当Promise 被 reject 且没有 reject 处理器的时候，会触发 unhandledrejection 事件。

``unhandledrejection instanceof PromiseRejectionEvent instanceof Event``

```
window.addEventListener('rejectionhandled', event => {
  console.log(event.reason);

  event.preventDefault(); // 防止默认处理（例如将错误输出到控制台）
});
```
## Vue.config.errorHandler
[Vue.config.errorHandler](https://cn.vuejs.org/v2/api/#errorHandler): 设置全局的错误捕获。

- ``Vue.config.errorHandler`` 会阻止错误冒泡到 ``window.error``
- 在``Vue.config.errorHandler``处理的方式，处理之后不会在控制台中打印出来，需额外``console.error``。

## Vue 生命周期 errorCaptured
[errorCaptured](https://cn.vuejs.org/v2/api/#errorCaptured): 子孙组件的错误捕获。**控制报错粒度，用于封装UI组件，并防止崩溃**
- 不能捕获组件自身中的错误
- errorCaptured 没有返回 false，错误就会一直向上传播(子 -> 父 -> 顶层 GlobalEventHandlers.onerror)

### Vue
#### Vue.config.errorHandler
## Sentry 错误收集应用
监控网页崩溃：window 对象的 load 和 beforeunload/Navigator.sendBeacon()
